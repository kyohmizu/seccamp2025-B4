# 2章 クラウドネイティブセキュリティの基礎

- [2章 クラウドネイティブセキュリティの基礎](#2章-クラウドネイティブセキュリティの基礎)
  - [1. クラウドネイティブセキュリティの概要](#1-クラウドネイティブセキュリティの概要)
    - [1.1 クラウドネイティブとは](#11-クラウドネイティブとは)
    - [1.2 クラウドネイティブセキュリティの定義と重要性](#12-クラウドネイティブセキュリティの定義と重要性)
    - [1.3 従来のセキュリティモデルとの違い](#13-従来のセキュリティモデルとの違い)
    - [1.4 クラウドネイティブアプリケーションのライフサイクルとセキュリティの統合](#14-クラウドネイティブアプリケーションのライフサイクルとセキュリティの統合)
    - [1.5 クラウドネイティブセキュリティの主要な原則と目標](#15-クラウドネイティブセキュリティの主要な原則と目標)
    - [1.6 責任共有モデル](#16-責任共有モデル)
    - [1.7 クラウドネイティブの4Cモデル](#17-クラウドネイティブの4cモデル)
  - [2. シフトダウンセキュリティ](#2-シフトダウンセキュリティ)
    - [2.1 シフトダウンセキュリティの概念](#21-シフトダウンセキュリティの概念)
    - [2.2 シフトレフトセキュリティとの関係性](#22-シフトレフトセキュリティとの関係性)
    - [2.3 シフトダウンセキュリティの主要な要素とチームの責任](#23-シフトダウンセキュリティの主要な要素とチームの責任)
      - [2.3.1 脆弱性の削減](#231-脆弱性の削減)
      - [2.3.2 設定ミスの削減](#232-設定ミスの削減)
      - [2.3.3 ソフトウェアサプライチェーンセキュリティの向上](#233-ソフトウェアサプライチェーンセキュリティの向上)
    - [2.4 シフトダウンセキュリティの実装アプローチとメリット](#24-シフトダウンセキュリティの実装アプローチとメリット)
      - [実装アプローチ](#実装アプローチ)
      - [メリット](#メリット)
  - [3. コンテナセキュリティ](#3-コンテナセキュリティ)
    - [3.1 コンテナセキュリティの重要性](#31-コンテナセキュリティの重要性)
    - [3.2 コンテナイメージのセキュリティ](#32-コンテナイメージのセキュリティ)
      - [3.2.1 脆弱性スキャンとイメージ強化](#321-脆弱性スキャンとイメージ強化)
      - [3.2.2 信頼できるイメージと最小限のイメージの利用](#322-信頼できるイメージと最小限のイメージの利用)
      - [3.2.3 イメージ署名とレジストリセキュリティ](#323-イメージ署名とレジストリセキュリティ)
    - [3.3 コンテナのランタイムセキュリティ](#33-コンテナのランタイムセキュリティ)
      - [3.3.1 権限の制限とリソース制約](#331-権限の制限とリソース制約)
      - [3.3.2 Linux Security Modules](#332-linux-security-modules)
      - [3.3.3 監視と脅威検出](#333-監視と脅威検出)
    - [3.4 CI/CDパイプラインにおけるセキュリティ統合](#34-cicdパイプラインにおけるセキュリティ統合)
    - [3.5 NIST SP 800-190の観点](#35-nist-sp-800-190の観点)
  - [4. Kubernetesセキュリティ](#4-kubernetesセキュリティ)
    - [4.1 Kubernetesセキュリティの概要](#41-kubernetesセキュリティの概要)
    - [4.2 Kubernetes APIサーバーのセキュリティ](#42-kubernetes-apiサーバーのセキュリティ)
      - [4.2.1 認証と認可のメカニズム](#421-認証と認可のメカニズム)
      - [4.2.2 RBAC (Role-Based Access Control)](#422-rbac-role-based-access-control)
      - [4.2.3 Admission Control (アドミッションコントロール)](#423-admission-control-アドミッションコントロール)
      - [4.2.4 Pod Security Standards](#424-pod-security-standards)
      - [4.2.5 シークレット管理](#425-シークレット管理)
    - [4.3 Security Contextによる実行時制御](#43-security-contextによる実行時制御)
    - [4.4 ネットワークポリシー](#44-ネットワークポリシー)
    - [4.5 ノードセキュリティとホストOSの強化](#45-ノードセキュリティとホストosの強化)
    - [4.7 ソフトウェアサプライチェーンセキュリティ](#47-ソフトウェアサプライチェーンセキュリティ)
  - [参考](#参考)
  - [次のステップ](#次のステップ)

本章では、クラウドネイティブセキュリティの基本的な概念、その重要性、従来のモデルとの違い、そしてライフサイクル全体にわたるセキュリティの統合について解説します。さらに、セキュリティを開発ライフサイクルの早期段階に組み込む「シフトレフト」の概念を補完し、プラットフォームレベルでのセキュリティの組み込みと自動化に焦点を当てる「シフトダウンセキュリティ」についてご紹介します。また、クラウドネイティブ環境の基盤となるコンテナとKubernetesのセキュリティについても、ベストプラクティスと主要な制御項目を説明します。

## 1. クラウドネイティブセキュリティの概要

### 1.1 クラウドネイティブとは

クラウドネイティブとは、コンテナ、サービスメッシュ、マイクロサービス、イミュータブルインフラストラクチャ、宣言型APIなどの技術を活用して、スケーラブルなアプリケーションを構築・実行するアプローチを指します。これは通常、オープンソース技術を利用し、クラウドコンピューティング環境で現代のアプリケーションを構築、デプロイ、運用することを含みます。

クラウドネイティブの定義には、コンテナ、サービスメッシュ、マイクロサービスといった複数の技術要素が含まれており、これらの技術はそれぞれが複雑であるだけでなく、組み合わせることでさらに複雑性が増大します。加えて、オープンソースエコシステムは非常に速い速度で進化しており、新しい技術やプラクティスが常に登場します。このため、セキュリティ対策も継続的な適応が求められることになります。このような複雑性と変化の速さが、クラウドネイティブセキュリティにおける根本的な課題を形成します。

### 1.2 クラウドネイティブセキュリティの定義と重要性

クラウドネイティブセキュリティは、従来のセキュリティモデルと同様に、精緻さ、整合性、信頼性、脅威防止の条件を確保しつつ、現代の「一過性（ephemerality）」「分散（distribution）」「不変性（immutability）」といった概念を統合することを目指します。

組織全体で戦略的に実行されるクラウドネイティブセキュリティは、高可用性、保証、回復力、大規模な冗長性を提供し、顧客と開発者が必要なリソースに期待する速度で安全にアクセスできるようにします。クラウドネイティブの目的は、迅速な開発とデプロイを通じてビジネス価値を加速させることにあります。セキュリティがこの速度を阻害するものであってはなりません。むしろ、セキュリティをアプリケーションのライフサイクルに組み込むことで、高可用性や回復力といった「価値」自体を高めることができるという視点は、セキュリティが単なるコストではなく、ビジネスの競争優位性となる可能性を示しています。

### 1.3 従来のセキュリティモデルとの違い

従来のセキュリティモデルでは、ネットワークIPアドレスのような静的な識別子に依存した境界型セキュリティが主流でしたが、クラウドネイティブ環境ではこのアプローチは非実用的です。クラウドネイティブは、開発者がコードからインフラまで全てを所有するダイナミックな環境であり、セキュリティも開発者のワークフローに適合するよう再構築される必要があります。

従来のセキュリティが「境界」を守ることに重点を置いていたのに対し、クラウドネイティブでは「静的な識別子の非実用性」が指摘されています。これは、インフラがコード化され、頻繁に変化し、コンポーネントが分散する環境では、固定的な境界線が意味をなさなくなることを意味します。そのため、セキュリティは開発プロセスの内部、具体的には「コード」と「ワークフロー」に深く組み込まれる必要があり、これはセキュリティアプローチの根本的な再考を要求するものです。

### 1.4 クラウドネイティブアプリケーションのライフサイクルとセキュリティの統合

クラウドネイティブ開発は、「開発（Develop）」「配布（Distribute）」「デプロイ（Deploy）」「実行時（Runtime）」という明確なアプリケーションライフサイクルフェーズでモデル化できます。セキュリティは、これらのライフサイクル全体にわたって注入されるべきであり、セキュリティテストは、継続的な改善のための短く実用的なフィードバックサイクルを生成するために、コンプライアンス違反や設定ミスを早期に特定する必要があります。

従来のセキュリティがインシデント発生後の「対応」に重点を置いていたのに対し、クラウドネイティブセキュリティは「ライフサイクル全体へのセキュリティの注入」を強調しています。これは、セキュリティを開発の初期段階から組み込むことで、問題を早期に発見し、修正するコストを削減し、最終的に「予防的セキュリティ」を実現するという明確なトレンドを示しています。

**表1: クラウドネイティブセキュリティのライフサイクルフェーズとセキュリティ対策**

| フェーズ | 主要なセキュリティ対策 |
|----------|----------------------|
| 開発 (Develop) | 開発環境の整合性確保、セキュアな設計原則の適用、脅威モデリング、コードレビュー、静的解析、依存関係スキャン |
| 配布 (Distribute) | ビルドパイプラインのセキュリティ、イメージスキャン、イメージ強化、イメージ署名、レジストリセキュリティ、テスト |
| デプロイ (Deploy) | デプロイ前チェック、マニフェストスキャン、バイナリ認証、ポリシー適用 |
| ランタイム環境 (Runtime) | 最小権限の適用、Pod Security Standardsの強制、監視、ネットワークポリシー、シークレット管理、監査ログ分析、ホストOS強化 |

![](https://github.com/cncf/tag-security/raw/main/community/resources/security-whitepaper/v2/cnswp-images/cnswp-v2-figure1.png)

### 1.5 クラウドネイティブセキュリティの主要な原則と目標

クラウドネイティブセキュリティは、精緻さ、整合性、信頼性、脅威防止といった従来の目標に加え、一過性、分散、不変性といった現代の概念を統合します。目標としては、高可用性、保証、回復力、大規模な冗長性の提供が挙げられます。

クラウドネイティブの特性である「一過性」「分散」「不変性」は、システムの障害耐性を高める一方で、セキュリティの管理を複雑にする側面も持ちます。しかし、これらの特性をセキュリティに統合することで、「高可用性、保証、回復力、冗長性」といったシステムの弾力性をセキュリティ面でも実現できるとされています。これは、セキュリティが単に攻撃を防ぐだけでなく、システム全体の堅牢性を高めるための重要な要素であることを示しています。

クラウドネイティブ環境におけるセキュリティは、以下の基本原則に基づいて設計される必要があります。

- **多層防御（Defense in Depth）**: 単一のセキュリティ対策に依存するのではなく、複数のセキュリティレイヤーを組み合わせて包括的な保護を実現するアプローチです。クラウドネイティブ環境では、ネットワーク、アプリケーション、データ、アイデンティティなど、各レイヤーでセキュリティ対策を講じることで、一つの防御が突破されても他の防御によって攻撃を阻止できる可能性を高めます。
- **最小権限（Least Privilege）**: ユーザーやシステムに対して、その機能を実行するために必要最小限の権限のみを付与します。これにより、万が一アカウントやシステムが侵害された場合でも、攻撃の影響範囲を限定することができます。クラウドネイティブ環境では、サービスアカウント、Pod、コンテナそれぞれのレベルで最小権限の原則を適用することが重要です。
- **ゼロトラスト（Zero Trust）**: 従来の境界防御とは異なり、ネットワークの内部外部を問わず、すべてのアクセス試行を検証し、認証と認可を行います。クラウドネイティブ環境では、動的に生成される多数のコンポーネント間で通信が行われるため、このアプローチが特に重要になります。
- **セキュリティ・バイ・デザイン（Security by Design）**: システムの設計段階からセキュリティを組み込むアプローチです。後からセキュリティ対策を追加するのではなく、アーキテクチャの設計時からセキュリティ要件を考慮し、セキュアなシステムを構築することで、より効果的で費用対効果の高いセキュリティを実現できます。

### 1.6 責任共有モデル

セキュリティは開発者だけの責任ではなく、アプリケーションチーム、プラットフォームチーム、セキュリティチーム間の「共有責任」であると認識されています。このモデルは、継続的な監視、自動化されたセキュリティ制御、セルフサービス、適応型セキュリティ対策を重視し、クラウドネイティブ環境の動的な性質に対応します。

セキュリティの責任が「共有」であるという概念は、単なる技術的な変更だけでなく、組織文化とチーム間のコラボレーションの変革を必要とします。開発者がセキュリティを「押し付けられる」と感じるのではなく、セキュリティが彼らのワークフローに自然に組み込まれ、価値を提供するものとして認識される必要があります。これは、セキュリティチームが「ゲートキーパー」から「イネーブラー」へと役割を変えることを意味します。

### 1.7 クラウドネイティブの4Cモデル

Kubernetesセキュリティは、Cloud、Cluster、Container、Codeの4つの層から構成される4Cモデルによって体系的に整理することができます。このモデルは、各レイヤーでの責任範囲を明確にし、包括的なセキュリティ戦略の構築を支援します。

- **クラウド（Cloud）**: Kubernetesクラスタが稼働する基盤となるクラウドインフラストラクチャのセキュリティを担当します。クラウドプロバイダが提供するセキュリティ機能の活用、ネットワークセキュリティの設計、アイデンティティ・アクセス管理（IAM）の実装が含まれます。
- **クラスタ（Cluster）**: Kubernetesクラスタ自体のセキュリティを担当し、APIサーバーの保護やノード間通信の保護などを含みます。Kubernetesの認証・認可機能を活用したアクセス制御が中心となります。
- **コンテナ（Container）**: コンテナイメージのセキュリティ、コンテナランタイムの保護、そしてレジストリセキュリティを担当します。このレイヤーでは、コンテナの供給チェーンセキュリティが特に重要になります。
- **コード（Code）**: アプリケーションコード自体のセキュリティ、依存関係の管理、そしてシークレット管理を担当します。このレイヤーは、最終的にユーザーに価値を提供するアプリケーションの核心部分であり、他のすべてのレイヤーのセキュリティ対策の効果は、このレイヤーのセキュリティ品質に大きく依存します。

![4c](https://kubernetes.io/images/docs/4c.png)

## 2. シフトダウンセキュリティ

シフトダウンセキュリティは、クラウドネイティブ環境におけるセキュリティアプローチの進化を象徴する概念です。シフトレフトセキュリティが開発ライフサイクルの早期段階に焦点を当てるのに対し、シフトダウンセキュリティはプラットフォームレベルでのセキュリティの組み込みと自動化に重点を置きます。本セクションでは、その概念、シフトレフトとの関係性、主要な要素、そして具体的な実装とメリットについて掘り下げます。

### 2.1 シフトダウンセキュリティの概念

シフトダウンセキュリティは、セキュリティが開発者だけの責任ではなく、アプリケーション、プラットフォーム、セキュリティチーム間の共有責任であるという認識に基づいています。このアプローチは、セキュリティをプラットフォームに直接組み込むことに焦点を当て、継続的な監視、自動化されたセキュリティ制御、セルフサービス、適応型セキュリティ対策を重視します。

シフトダウンセキュリティの核心は、各アプリケーションチームが個別にセキュリティ懸念に対処するのではなく、プラットフォームチームが共通のセキュリティ要素を中央集権的に管理し、自動化されたガードレールとして提供することにあります。これにより、開発者はセキュリティの専門知識がなくても、デフォルトで安全な環境で作業できるようになり、セキュリティの専門家はより高度な脅威分析やポリシー策定に集中できる環境が構築されます。

### 2.2 シフトレフトセキュリティとの関係性

シフトダウンセキュリティは、ソフトウェア開発ライフサイクル（SDLC）の早期にセキュリティプラクティスを統合する「シフトレフトセキュリティ」を補完するものです。シフトレフトは大きな利点を提供する一方で、クラウドネイティブ環境の複雑性や動的な性質により、開発者がすべてのセキュリティリスクを効果的に軽減することが難しいという課題に直面します。

シフトダウンは、開発からデプロイ、実行環境まで、すべてのアプリケーションとライフサイクル全体でセキュリティを標準化し、強制することで、シフトレフトセキュリティを拡張します。シフトレフトが開発者にセキュリティの責任を「シフト」する側面があるのに対し、シフトダウンはプラットフォームが共通のセキュリティ課題を「引き受ける」ことで、開発者の負担を軽減し、セキュリティを組織全体でスケールさせることを目指しています。これは、セキュリティが開発速度を阻害する「摩擦」ではなく、イノベーションを加速する「イネーブラー」となるための重要な戦略的転換点であると捉えられます。

### 2.3 シフトダウンセキュリティの主要な要素とチームの責任

成功するシフトダウンセキュリティ戦略を定義する3つの主要な要素があります。

- **横断的なセキュリティ懸念がプラットフォームによって対処される**: 各アプリケーションチームが直接セキュリティ懸念に対処するのではなく、プラットフォームエンジニアリングチームが共通の懸念を特定し、対処します。
- **セキュリティはコード化され、自動化され、協調的である**: Policy as Code (PaC) のようなベストプラクティスにより、セキュリティを自動化し、アプリケーションライフサイクル全体で積極的に強制できます。セキュリティ関連の成果物は、バージョン管理やコードレビューなどのソフトウェアエンジニアリングのベストプラクティスを使用して「コードとして」管理されるべきです。
- **プラットフォームセキュリティはシフトレフトと既存のプロセスを補完する**: 組織の共通のセキュリティ要素をプラットフォームに移行することは、セキュリティプロセスを向上させ、最適化し、結果を改善することを目的としています。これは、すべての関係者が参加し、貢献する必要性を置き換えるものではありません。

これらの要素は、組織全体にわたる横断的な領域、特に以下の3つの主要なセキュリティ課題に対処します。

![](https://github.com/kubernetes/sig-security/raw/main/sig-security-docs/papers/shift-down/images/shift-down-teams.png)

#### 2.3.1 脆弱性の削減

プラットフォームチームは、最小限に強化されたコンテナベースイメージを維持・更新し、不必要なパッケージや依存関係を削除することで、脆弱性の数を大幅に削減できます。これにより、アプリケーションチームが対処すべき脆弱性の数が減り、時間とコストが節約されます。

- **プラットフォームチームの責任**: 最小限で強化されたコンテナベースイメージの維持、イメージ管理プロセスの自動化、ビルドパイプラインでのCVEスキャンとレポートの自動化。
- **アプリケーションチームの責任**: ベースイメージとアプリケーション依存関係の定期的な更新、アプリケーションリポジトリのCVE監視。
- **セキュリティチームの責任**: CVEに関する組織標準とSLAの確立、コンプライアンスのための本番環境監視、例外の承認。

#### 2.3.2 設定ミスの削減

プラットフォームチームは、Pod Security Standards (PSS) やRBAC、共通のネットワークポリシーなどのガードレールを実装し、Policy as Code (PaC) を使用してセキュリティポリシーを定義・強制することで、設定ミスを防止します。

- **プラットフォームチームの責任**: セキュリティ、コンプライアンス、コスト、運用ベストプラクティスのPolicy as Codeの定義と維持、関連クラスタへのポリシー成果物のデプロイ管理、CI/CDパイプライン、クラスタ、その他のランタイム環境のポリシー強制ポイントの管理。
- **セキュリティチームの責任**: 必要な組織のガバナンスとコンプライアンス標準の定義、ポリシー例外に対処するためのSLA要件の定義、チーム間のポリシー例外の管理。

#### 2.3.3 ソフトウェアサプライチェーンセキュリティの向上

プラットフォームエンジニアリングチームは、ビルドシステムとデリバリーパイプラインのベストプラクティス、セキュリティ、コンプライアンスを確保するのに役立ちます。コンテナイメージに署名し、デプロイ前にこれらのイメージの出所と整合性を検証するために、アドミッションコントロールと統合されたPolicy as Codeソリューションを使用することがベストプラクティスです。

脆弱性、設定ミス、サプライチェーンのセキュリティという3つの主要な課題は、それぞれがSDLCの異なるフェーズにまたがっています。シフトダウンは、これらの課題に対して「プラットフォームによる横断的な対処」「コード化・自動化・協調性」「シフトレフトの補完」という共通のアプローチを提供しています。これは、クラウドネイティブ環境の動的な性質に対応するためには、手動でのセキュリティチェックでは追いつかず、自動化とポリシーによる一貫した強制が不可欠であることを示しています。

**表2: シフトダウンセキュリティにおけるチームの責任**

| 責任領域 | プラットフォームチームの責任 | アプリケーションチームの責任 | セキュリティチームの責任 |
|----------|------------------------------|------------------------------|-------------------------|
| 脆弱性の削減 | 最小限で強化されたベースイメージの維持、イメージ管理・CVEスキャン・レポートの自動化 | ベースイメージと依存関係の定期的な更新、アプリケーションリポジトリのCVE監視 | CVEに関する組織標準・SLAの確立、本番環境のコンプライアンス監視、例外の承認 |
| 設定ミスの削減 | Policy as Codeの定義・維持・デプロイ、ポリシー強制ポイントの管理 | - | 組織のガバナンス・コンプライアンス標準の定義、ポリシー例外の承認・管理 |
| ソフトウェアサプライチェーンセキュリティの向上 | イメージ署名・検証の実装、ビルドシステム・デリバリーパイプラインの標準化 | - | - |

### 2.4 シフトダウンセキュリティの実装アプローチとメリット

#### 実装アプローチ

シフトダウンセキュリティは、Policy as Code (PaC) を使用したセキュリティ自動化、開発者、運用、セキュリティ間のコラボレーション、およびKubernetes環境のセキュリティと回復力を確保するための継続的なチューニングの組み合わせを必要とします。

#### メリット

- **プロアクティブな強制**: 共通のセキュリティ懸念をプラットフォームに移行することで、開発者向けのセキュリティを拡張し、リスクを積極的に特定し、悪用される前にそれらに対処できます。
- **ノイズの削減**: 中央のセキュリティチームは、対処できない可能性のある何千ものアラートではなく、重要なことに集中できます。
- **俊敏性の向上**: 脆弱性が少なく、設定ミスが早期に防止されるため、開発者は退屈なタスクに時間を費やすことなく、ビジネス価値の提供に集中できます。
- **適応型セキュリティ**: 自動化されたセキュリティ制御は、Kubernetes環境の動的な性質に適応し、セキュリティポリシーが一貫して強制されることを保証します。
- **コラボレーションの改善**: 共有責任モデルはチーム間のコラボレーションを促進し、より効果的なセキュリティ結果につながります。
- **可視性の向上**: 継続的な監視は、Kubernetes環境のセキュリティ状況を可視化し、脅威の迅速な検出と対応を可能にします。

シフトダウンセキュリティは、セキュリティの「効率性」（ノイズ削減、俊敏性向上）と「効果性」（プロアクティブな強制、適応型セキュリティ）の両方を追求するものです。これは、セキュリティが開発プロセスのボトルネックになるのではなく、むしろ加速する要因となりうることを示しており、クラウドネイティブ環境での競争力を高める上で極めて重要な戦略です。

## 3. コンテナセキュリティ

コンテナ技術は、クラウドネイティブアプリケーションの基盤であり、そのセキュリティはシステム全体の堅牢性に直結します。

### 3.1 コンテナセキュリティの重要性

コンテナセキュリティのベストプラクティスは、配布されるアプリケーションやコンテナイメージ自体の保護だけでなく、コンテナのビルド、配布、実行に使用されるコンポーネントスタック全体を保護することを含みます。これには、ホストまたはVM、コンテナランタイムが含まれます。コンテナは、Linuxカーネルのnamespace機能（PID, NET, MOUNTなど）を利用してプロセスを分離し、cgroup（control group）によりリソース（CPU、メモリ）を制限することで、優れたレベルのセキュリティと分離を提供します。

NIST SP 800-190 (Application Container Security Guide) は、コンテナ化されたアプリケーションのセキュリティ懸念に対処するために発行され、一般的な脅威、セキュリティ強化ガイドライン、運用上の考慮事項を概説しています。コンテナは「ホストまたはVM」「コンテナランタイム」「イメージ」「アプリケーション」といった複数のレイヤーに依存しています。この複雑なスタックのどこか一つでも脆弱性があれば、システム全体が危険に晒される可能性があります。したがって、コンテナセキュリティは単一の対策ではなく、これらのすべてのレイヤーにわたる多層防御戦略を必要とします。

### 3.2 コンテナイメージのセキュリティ

#### 3.2.1 脆弱性スキャンとイメージ強化

コンテナイメージの脆弱性を定期的にスキャンし、速やかに更新を適用することが不可欠です。これは、ベースイメージとすべてのパッケージを脆弱性データベースに対してスキャンすることで行われます。イメージスキャンツールは、コンテナイメージに含まれるアプリケーションやライブラリが既知の脆弱性（CVE）から解放されていることを確認します。

コンテナイメージの脆弱性は、それがデプロイされるすべてのコンテナに「継承される」ため、非常に広範囲な影響を及ぼす可能性があります。したがって、開発ライフサイクルの早い段階（CI/CDパイプライン内）でイメージスキャンを統合し、脆弱性を「予防」することが、後の段階での高コストなインシデント対応を避ける上で極めて重要です。

#### 3.2.2 信頼できるイメージと最小限のイメージの利用

信頼できるイメージを使用するか、検証済みのベースイメージからイメージを構築します。攻撃対象領域を最小限に抑えるために、不要なコンポーネントや依存関係を削除し、ベースイメージを「最小限」に保つことが推奨されます。これは、`FROM scratch`を使用したり、「distroless」イメージやAlpineイメージから始めることで実現できます。

「最小限のイメージ」は、単にサイズが小さいだけでなく、潜在的な攻撃対象となる「不必要なパッケージや依存関係」を排除することを意味します。これは、セキュリティの基本原則である「攻撃対象領域の最小化」をコンテナ環境で実践する具体的な方法であり、未知の脆弱性に対するリスクも軽減します。

Chainguard 社が提供する [Chainguard Images](https://www.chainguard.dev/chainguard-images) には、多くの OSS の distroless イメージが格納されています。

#### 3.2.3 イメージ署名とレジストリセキュリティ

イメージコンテンツの信頼性を強化し、デプロイ前にイメージの署名を検証することが重要です。コンテナレジストリへのアクセス制御を実装し、イメージをプッシュおよびプルできるユーザーを制限します。レジストリにプッシュする前に脆弱性スキャンを行い、コンテナとレジストリ間のデータ転送には暗号化された接続を使用します。

イメージ署名とレジストリセキュリティは、ソフトウェアサプライチェーンの整合性を確保するための重要な要素です。イメージが信頼できるソースから来ており、改ざんされていないことを検証することで、悪意のあるコードや脆弱性が本番環境に到達するリスクを大幅に低減できます。これは、サプライチェーン攻撃が増加する現代において、特に重要性が増しています。

### 3.3 コンテナのランタイムセキュリティ

#### 3.3.1 権限の制限とリソース制約

コンテナをrootとして実行しないこと、DockerやKubernetesが提供する権限削除機能を利用すること、特権コンテナを許可しないことなど、実行時にコンテナ権限を制限することが推奨されます。Linuxのcapability機能により、従来のroot権限を細分化し、必要な権限のみを個別に付与することで最小権限の原則を実現します。

`--security-opt=no-new-privileges`フラグを使用して特権昇格を防ぎます。CPUやメモリなどのリソースに制限を設定し、DoS攻撃を防ぎます。コンテナの実行時におけるセキュリティのポイントは、「最小権限の原則」を徹底することにあります。コンテナが持つ権限やリソースを必要最小限に制限することで、仮にコンテナが侵害された場合でも、攻撃者がシステム全体に与える影響を最小限に抑えることができます。これは、セキュリティ侵害の「影響範囲」を限定するための重要な戦略です。

#### 3.3.2 Linux Security Modules

Linux Security Modules（LSM）を使用し、デフォルトのセキュリティプロファイルを無効にしないことが推奨されます。これらは、コンテナのシステムコールやファイルシステムアクセスを制限し、追加のセキュリティレイヤーを提供します。

コンテナはホストOSのカーネルを共有するため、カーネルレベルでの防御はコンテナエスケープなどの深刻な攻撃を防ぐ上で極めて重要です。Seccomp, AppArmor, SELinuxといったLSMは、コンテナが実行できる操作を細かく制御し、カーネルレベルでの攻撃対象領域を縮小することで、コンテナの隔離性を強化します。

#### 3.3.3 監視と脅威検出

リアルタイム監視と異常検出を実装し、脅威を迅速に特定し対応します。ホストとKubernetesのログ、クラウドログ、コンテナ内のシステムコールを監査することで、異常なアクティビティを検出できます。MITRE ATT&CK Matrix for Containersは、コンテナ技術に特化した手法をカバーしており、脅威検出のフレームワークとして活用できます。

クラウドネイティブ環境は動的であり、デプロイ後も設定変更や新たな脆弱性が生じる可能性があります。そのため、実行時における「継続的な監視と脅威検出」は、予防策をすり抜けた脅威や未知の脅威に対応するために不可欠です。ログ監査や異常検出は、インシデント発生時の迅速な対応とフォレンジック分析の基盤となります。

### 3.4 CI/CDパイプラインにおけるセキュリティ統合

CI/CDプロセスにコードスキャン、依存関係スキャン、イメージスキャンを統合することが、セキュリティを「シフトレフト」するための重要なステップです。Linterをビルドパイプラインのステップとして追加することで、Dockerfileのベストプラクティスを強制し、一般的な問題（USER 句の指定、ベースイメージバージョンの固定、不必要なADDの回避など）を防ぐことができます。

CI/CDパイプラインへのセキュリティツールの統合は、セキュリティチェックを自動化し、開発者が慣れ親しんだワークフローの中でフィードバックを受け取れるようにすることで、セキュリティのボトルネックを解消します。これにより、セキュリティが開発速度を阻害するものではなく、品質保証の一部として自然に組み込まれるようになります。

### 3.5 NIST SP 800-190の観点

NIST SP 800-190は、コンテナ化されたアプリケーションのセキュリティガイドであり、イメージセキュリティ、レジストリセキュリティ、オーケストレータセキュリティ、コンテナセキュリティ、ホストOSセキュリティ、ハードウェアセキュリティの主要な側面をカバーしています。このガイドは、DevSecOpsワークフローにおけるセキュアなコンテナ化の実装を支援し、コンプライアンスを確保し、攻撃対象領域を削減することを目指します。NIST SP 800-190は、Pod Security Standards (PSS) やPod Security Policy (PSP) といったKubernetesセキュリティ標準とも関連しており、Policy Controllerのようなツールでこれらのコントロールを強制できます。

NIST SP 800-190のような公式ガイドラインは、コンテナセキュリティの複雑な領域において、組織が体系的かつ包括的なセキュリティ戦略を策定するための標準的なフレームワークを提供します。これにより、ベストプラクティスが明確になり、コンプライアンス要件への対応も容易になります。Policy-as-Codeによる自動化は、これらの標準を大規模に適用するための鍵となります。

**表3: コンテナセキュリティの主要なベストプラクティス概要**

| 領域 | ベストプラクティス |
|------|-------------------|
| イメージセキュリティ | 脆弱性スキャン、最小イメージの利用、信頼できるソースからの取得、イメージ署名、シークレットの埋め込み回避 |
| レジストリセキュリティ | 厳格なアクセス制御、セキュアな通信（TLS/SSL）、イメージライフサイクル管理 |
| 実行時セキュリティ | 最小権限の適用（root以外のユーザー実行、権限削除）、リソース制限、特権昇格防止、LSM（Seccomp, AppArmor, SELinux）の利用、監視・脅威検出、不変インフラストラクチャ |
| CI/CD統合 | コードスキャン、依存関係スキャン、イメージスキャン、LinterのCI/CDパイプラインへの統合 |
| ホストOSセキュリティ | 最小OSの利用、カーネル強化、ホストOSへのアクセス制限、ファイルシステム保護 |

## 4. Kubernetesセキュリティ

Kubernetesは、コンテナ化されたワークロードをオーケストレーションするためのデファクトスタンダードであり、そのセキュリティはクラウドネイティブ環境全体のセキュリティに直接影響します。

### 4.1 Kubernetesセキュリティの概要

Kubernetesは、コンテナ、ネットワーク、ストレージ、認証・認可など、多数のコンポーネントが複雑に連携して機能する分散システムです。そのため、セキュリティは単一のコンポーネントに限定されず、4CやSDLCなどのモデルが示すように、コードから基盤となるクラウドインフラまでのすべてのレイヤーで、また開発ライフサイクルのすべてのフェーズで包括的に考慮される必要があります。

### 4.2 Kubernetes APIサーバーのセキュリティ

Kubernetes APIサーバーは、クラスタの中央通信チャネルであり、ユーザー、クラスタの異なる部分、外部コンポーネントが相互に通信するためのHTTP APIを公開しています。このAPIの保護は、効果的なクラスタセキュリティを提供する上で鍵となります。

#### 4.2.1 認証と認可のメカニズム

- **認証**: APIアクセスを試みるユーザーやコンポーネントの身元を確認します。クライアント証明書、ベアラートークン、認証プロキシが使用されます。
- **認可**: 認証されたユーザーやコンポーネントが実行を許可されるアクションを決定します。権限はデフォルトで拒否されます。

Kubernetes APIサーバーは、クラスタの「司令塔」として機能し、クラスタ内のすべての操作の中心となります。したがって、APIサーバーへの不正アクセスはクラスタ全体の制御を奪われることに等しいです。認証と認可のメカニズムを厳格に適用することは、この最も重要なコントロールプレーンコンポーネントを保護するための最初の、そして最も重要なステップです。

#### 4.2.2 RBAC (Role-Based Access Control)

Kubernetes RBACは、クラスタ内の任意のオブジェクトまたはオブジェクトタイプに対してロール（権限のセット）を作成および付与できるコアコンポーネントです。Kubernetes 1.6以降、RBACはデフォルトで有効になっています。

RBACは、Kubernetes環境における「最小権限の原則」を実装するための主要なメカニズムです。ユーザーやアプリケーションに必要最小限の権限のみを付与することで、不正アクセスや侵害が発生した場合の影響を限定できます。また、NamespaceスコープのRoleとClusterRoleの組み合わせは、マルチテナント環境において、テナント間の厳格な分離とリソースアクセス制御を実現するための基盤となります。

**表4: Kubernetes RBACの主要コンポーネント**

| コンポーネント | スコープ | 役割/目的 |
|---------------|----------|-----------|
| Role | Namespaceレベル | 特定のNamespace内のリソースに対する許可された操作を定義 |
| ClusterRole | クラスタレベル | クラスタ全体のリソース、非リソースエンドポイント、またはすべてのNamespaceにわたるリソースに対する許可された操作を定義 |
| RoleBinding | Namespaceレベル | RoleまたはClusterRoleを特定のNamespace内のユーザー/グループ/ServiceAccountに割り当て |
| ClusterRoleBinding | クラスタレベル | ClusterRoleをクラスタ全体にわたるユーザー/グループ/ServiceAccountに割り当て |
| ServiceAccount | Namespaceレベル | Pod内で実行されるプロセスにIDを提供し、RBACを通じて権限が付与される |

#### 4.2.3 Admission Control (アドミッションコントロール)

認証と認可の後、アドミッションコントローラーがAPIサーバーへのリクエストをインターセプトし、etcdに永続化される前にリクエストを変更または拒否することを可能にします。Pod Security Admission (PSA) は、Pod Security Standardsを強制するための組み込みアドミッションコントローラーです。

アドミッションコントロールは、APIサーバーへのリクエストがクラスタの状態を変更する前に、最終的なセキュリティチェックとポリシー強制を行う「最終防衛線」として機能します。これにより、不正な設定やポリシー違反のあるリソースがクラスタにデプロイされるのを防ぎ、セキュリティ体制の一貫性を保つことができます。

#### 4.2.4 Pod Security Standards

Pod Security Standards (PSS) は、Podのセキュリティを強化するための一連のベストプラクティスとポリシーです。PSSは、特権コンテナの禁止、ホストネットワークやPID名前空間の使用の制限、読み取り専用ルートファイルシステムの強制、機能の制限など、コンテナの基本的な設定ミスを直接対処します。PSSには、Privileged、Baseline、Restrictedの3つのプロファイルがあり、それぞれ異なるレベルのセキュリティを提供します。

PSSは、Kubernetes環境におけるPodの「デフォルトセキュリティ」を大幅に向上させることを目的としています。これらの標準をポリシーとして強制することで、開発者がセキュリティの専門知識がなくても、意図せず脆弱なPodをデプロイしてしまうリスクを低減できます。Policy Controllerのようなツールと組み合わせることで、これらの標準の監査と強制を自動化し、コンプライアンス要件への対応を効率化できます。

**表5: Pod Security Standards (PSS) の主要な制御項目**

| PSSプロファイル | 主要な制御項目（例） |
|----------------|-------------------|
| Baseline | AppArmorプロファイル、Linux Capabilities、ホスト名前空間（PID, IPC, Network）、ホストポート、HostPathボリューム、特権コンテナ、Proc Mountタイプ、Seccompプロファイル、SELinuxコンテキスト、Sysctls |
| Restricted | Linux Capabilities、特権昇格の制限、ボリュームタイプ、非rootユーザーでの実行、ユーザーID、Seccompプロファイル |

#### 4.2.5 シークレット管理

Kubernetesのシークレットは、パスワード、キー、トークンなどの機密情報を保持するために使用されるオブジェクトです。シークレット値はbase64エンコードされて保存されますが、これは暗号化の代わりではありません。Kubernetesは、保存されているオブジェクトに対して複数の暗号化スキームをサポートしており、KMSプロバイダーとの統合も可能です。

シークレット管理は、クラウドネイティブアプリケーションにおける機密データの漏洩を防ぐ上で極めて重要です。シークレットはコードにハードコードせず、安全なシークレット管理ツールを使用し、保存時および転送中の暗号化を徹底する必要があります。これは、機密データの生成から破棄までのライフサイクル全体にわたる厳格な管理が求められることを意味します。

### 4.3 Security Contextによる実行時制御

Security Contextは、PodとContainerレベルでの詳細なセキュリティ設定を可能にする機能です。Pod Security Contextでは、Pod全体に適用されるセキュリティ設定を定義します。非rootユーザーでの実行強制（`runAsNonRoot: true`）により、特権昇格攻撃のリスクを大幅に削減できます。特定のユーザーIDとグループIDの指定により、ファイルシステムアクセス権限を細かく制御し、最小権限の原則を実現します。

seccompプロファイルの適用により、コンテナが実行できるシステムコールを制限し、攻撃者が悪用可能な機能を大幅に削減できます。RuntimeDefaultプロファイルの使用により、一般的なセキュリティ基準に準拠した制限を自動的に適用できます。

Container Security Contextでは、コンテナ個別のセキュリティ設定をより詳細に制御できます。privilege escalationの禁止により、実行時の権限昇格を防ぎ、read-only root filesystemの設定により、ファイルシステムへの書き込みを制限します。capabilitiesの細かな制御により、必要最小限の特権のみを付与し、不要な権限は明示的に削除します。

### 4.4 ネットワークポリシー

Kubernetesネットワークポリシーは、Podレベルのファイアウォールルールを作成し、クラスタ内のどのPodとサービスが相互にアクセスできるかを決定します。デフォルトでは、クラスタ内のすべてのPodは自由に通信できます。

- **IngressとEgress**: IngressはPodへの受信トラフィック、EgressはPodからの送信トラフィックを指します。
- **デフォルトの拒否/許可**: ネットワークポリシーがPodに適用されない場合、すべてのトラフィックはデフォルトで許可されます（デフォルト許可）。しかし、1つ以上のネットワークポリシーがPodに適用されると、そのポリシーで具体的に定義されたトラフィックのみが許可され、それ以外は拒否されます（デフォルト拒否）。

Kubernetesネットワークポリシーは、従来のネットワーク境界防御から一歩進んで、Podレベルでの「マイクロセグメンテーション」を可能にします。これにより、仮にPodが侵害されたとしても、攻撃者が横方向に移動（ラテラルムーブメント）して他のPodやサービスにアクセスするのを制限できます。これは、ゼロトラスト原則をネットワーク層で実装する重要な手段です。

### 4.5 ノードセキュリティとホストOSの強化

Kubernetesノード（ワーカーノード）は、コンテナが実際に実行される基盤となるインフラストラクチャであり、そのセキュリティは極めて重要です。

- **最小限のOSの利用**: コンテナ化されたワークロードの実行に特化して設計された、読み取り専用（イミュータブル）の最小限のオペレーティングシステムを使用することが推奨されます。これにより、攻撃対象領域が減少し、コンテナエスケープが発生した場合のリスクを低減できます。
- **カーネル強化**: セキュリティパッチを適用し、カーネルを強化してエクスプロイトから保護します。
- **アクセス制限**: ホストOSへのアクセスを制限し、不正な試行を監視します。コンテナがホスト上で持つ特権を最小限に抑えることも重要です。

ノードセキュリティは、コンテナとKubernetesクラスタ全体の「信頼の基盤」を形成します。ホストOSの攻撃対象領域を最小化し、カーネルを強化することは、コンテナエスケープや特権昇格といった深刻な攻撃を防ぐ上で不可欠です。これは、ソフトウェアサプライチェーンのセキュリティが、アプリケーションコードだけでなく、その実行基盤となるOSやハードウェアの信頼性にも依存していることを示しています。

### 4.7 ソフトウェアサプライチェーンセキュリティ

ソフトウェアサプライチェーンの安全性は、迅速なソフトウェアイテレーションを可能にするモデルにおいて特に重要です。クラウドネイティブアプリケーションのライフサイクルには、ワークロード自体の整合性だけでなく、ワークロード作成プロセスと運用手段を検証する方法を含める必要があります。

イメージの署名と検証、SBOM (Software Bill of Materials) の統合、信頼できるレジストリの使用、CI/CDパイプラインでの自動化されたセキュリティチェックなどが重要です。

クラウドネイティブ環境におけるソフトウェアサプライチェーンセキュリティは、コードのコミットから本番環境へのデプロイまでの「信頼の連鎖」を確立し、その連鎖の各段階で「継続的な検証」を行うことを意味します。これは、単一の脆弱性や侵害がサプライチェーン全体に波及し、広範な影響を与えるリスクを軽減するために不可欠であり、組織がセキュリティを「開発プロセスの側面」としてではなく、「ビジネスリスク管理の核心」として捉える必要性を示唆しています。

## 参考

- https://github.com/bloomberg/cncf-toc/blob/master/DEFINITION.md
- https://github.com/cncf/tag-security/blob/main/community/resources/security-whitepaper/v2/cloud-native-security-whitepaper.md
- https://www.paloaltonetworks.com/cyberpedia/shift-left-security
- https://github.com/kubernetes/sig-security/blob/main/sig-security-docs/papers/shift-down/shift-down-security.md
- https://csrc.nist.gov/pubs/sp/800/190/final
- https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html
- https://cheatsheetseries.owasp.org/cheatsheets/Kubernetes_Security_Cheat_Sheet.html
- https://www.cisecurity.org/benchmark/kubernetes

---

## 次のステップ

- [演習2 コンテナセキュリティ](./training.md)
- [3章 セキュリティアセスメント](../03_security_assessment/README.md)
